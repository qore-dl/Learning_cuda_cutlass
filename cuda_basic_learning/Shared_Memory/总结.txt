5.7 总结
为了获得最大的应用性能，需要有一个能显式地管理的内存层次结构。
在 C 语言中，没有直接控制数据移动的方式。在本章中，介绍了不同 CUDA 内存层次结构类型，
如共享内存、常量内存和只读缓存。介绍了当从共享内存中引入或删除数据时如何显式控制以显著提高其性能。
还介绍了常量内存和只读缓存的行为，以及如何最有效地使用它们。

共享内存可以被声明为一维或二维数组，它能为每个程序提供一个简单的逻辑视图，物理上，共享内存是一维的，
并能通过 32 个存储体进行访问。避免存储体冲突是在共享内存应用优化过程中一个重要的因素。
共享内存被分配在所有常驻线程块中，因此，它是一个关键资源，可能会限制内核占用率。

在内核中使用共享内存有两个主要原因：
1. 用于缓存片上数据并且减少全局内存访问量；
2. 传输共享内存中数据的安排方式，避免非合并的全局内存访问。

常量内存对只读数据进行了优化，这些数据每次都将数据广播到许多线程中。
常量内存也使用自己的 SM 缓存，防止常量内存的读操作通过一级缓存干扰全局内存的访问。
因此，对合适的数据使用常量内存，不仅可以优化特定项目的访问，还可能提高整体全局内存吞吐量。

只读纹理缓存提供了常量内存的代替方案，该方案优化了数据的分散读取。
只读缓存访问全局内存中的数据，但它使用一个独立的内存访问流水线和独立的缓存，
以使 SM 可以访问数据。
因此，只读缓存共享了常量内存的许多好处，同时对不同的访问模式也进行了优化。

洗牌指令时线程束级的内部功能，能使线程束中的线程彼此之间快速直接地共享数据。
洗牌指令具有比共享内存更低的延迟，并且不需要分配额外的资源。
使用洗牌指令可以减少内核中线程束同步优化的数目。
然而，在许多情况下，洗牌指令不是共享内存的代替品，因为共享内存在整个线程块中都可见。

本章对一些具有特殊用途的内存类型进行了深度了解。虽然这些内存类型比全局内存使用得少，
但是适当地使用它们可以提高带宽利用率，降低整体的内存延迟。如果你正在研究优化的因素，
那么牢记共享内存、常量内存、只读缓存和洗牌指令都是非常重要的。